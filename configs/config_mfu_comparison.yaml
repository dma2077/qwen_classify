# MFU计算方法对比配置
# 展示不同MFU计算方法的配置选项

# 基础训练配置
training:
  num_epochs: 3
  logging_steps: 10
  save_steps: 100
  eval_steps: 50
  
  # 评估配置
  evaluation:
    partial_eval_during_training: true
    full_eval_at_end: true
    eval_best_model_only: true
  
  # 最佳模型追踪
  best_model_tracking:
    enabled: true
    metric: "overall_accuracy"
    mode: "max"
    save_best_only: true

# 监控配置 - 不同MFU计算方法的配置
monitoring:
  # MFU计算方法选择
  mfu_calculation_mode: "smart"  # 可选: "smart", "profiler", "estimate", "hybrid"
  
  # 监控频率配置
  all_freq: 10  # 每10步记录一次
  
  # 性能监控配置
  performance_monitoring:
    enabled: true
    measure_flops_frequency: 500  # 每500步测量一次FLOPs
    use_precise_mfu: true  # 使用精确MFU计算
    
    # 智能模式配置
    smart_mode:
      initial_profiling: true  # 首次使用profiler
      calibration_enabled: true  # 启用校准
      recalibration_frequency: 1000  # 每1000步重新校准
    
    # Profiler模式配置
    profiler_mode:
      profile_memory: false  # 不记录内存使用以减少开销
      record_shapes: true
      with_flops: true
    
    # 混合模式配置
    hybrid_mode:
      hardware_counters_enabled: true  # 启用硬件计数器
      fallback_to_profiler: true  # 硬件计数器失败时回退到profiler

# 数据集配置
datasets:
  dataset_configs:
    food101:
      name: "food101"
      num_classes: 101
      eval_split: "validation"
    imagenet:
      name: "imagenet-1k"
      num_classes: 1000
      eval_split: "validation"

# DeepSpeed配置
deepspeed:
  train_micro_batch_size_per_gpu: 4
  gradient_accumulation_steps: 4
  train_batch_size: 64
  steps_per_print: 10
  
  # 优化器配置
  optimizer:
    type: "AdamW"
    params:
      lr: 1e-5
      weight_decay: 0.01
      eps: 1e-8
  
  # 学习率调度器
  scheduler:
    type: "WarmupLR"
    params:
      warmup_min_lr: 0
      warmup_max_lr: 1e-5
      warmup_num_steps: 100
  
  # ZeRO优化
  zero_optimization:
    stage: 2
    offload_optimizer:
      device: "cpu"
      pin_memory: true
    offload_param:
      device: "cpu"
      pin_memory: true
    overlap_comm: true
    contiguous_gradients: true
    reduce_bucket_size: 5e8
    stage3_prefetch_bucket_size: 5e8
    stage3_param_persistence_threshold: 5e6
    sub_group_size: 1e9
    stage3_max_live_parameters: 1e9
    stage3_max_reuse_distance: 1e9
    stage3_gather_16bit_weights_on_model_save: true

# 模型配置
model:
  name: "Qwen/Qwen2.5-VL-7B-Instruct"
  revision: "main"
  torch_dtype: "bfloat16"
  device_map: "auto"
  trust_remote_code: true

# 数据加载器配置
data:
  train_batch_size: 64
  eval_batch_size: 64
  num_workers: 4
  pin_memory: true
  persistent_workers: true

# 输出配置
output_dir: "./outputs/mfu_comparison_test"
save_deepspeed_format: true
save_hf_format: true

# WandB配置
wandb:
  enabled: true
  project: "qwen-classify-mfu-comparison"
  name: "mfu-calculation-comparison"
  log_dataset_metrics: true
  
  # 指标配置
  metrics:
    # 训练指标
    training:
      - "train/loss"
      - "train/learning_rate"
      - "train/grad_norm"
      - "train/mfu"
      - "train/throughput"
    
    # 评估指标
    evaluation:
      - "eval/overall_loss"
      - "eval/overall_accuracy"
      - "eval/food101_accuracy"
      - "eval/imagenet_accuracy"
    
    # 性能指标
    performance:
      - "perf/mfu"
      - "perf/throughput"
      - "perf/gpu_memory"
      - "perf/cpu_memory"
      - "perf/step_time"

# 日志配置
logging:
  level: "INFO"
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  
# 实验配置 - 用于对比不同MFU计算方法
experiments:
  # 实验1: 智能模式 (推荐用于生产环境)
  smart_mode:
    description: "智能MFU计算 - 首次精确测量，后续校准估算"
    mfu_calculation_mode: "smart"
    performance_monitoring:
      measure_flops_frequency: 500
      smart_mode:
        initial_profiling: true
        calibration_enabled: true
        recalibration_frequency: 1000
  
  # 实验2: Profiler模式 (推荐用于研究/调试)
  profiler_mode:
    description: "Profiler MFU计算 - 每次精确测量"
    mfu_calculation_mode: "profiler"
    performance_monitoring:
      measure_flops_frequency: 50  # 更频繁的测量
      profiler_mode:
        profile_memory: false
        record_shapes: true
        with_flops: true
  
  # 实验3: 估算模式 (推荐用于快速原型)
  estimate_mode:
    description: "估算MFU计算 - 无profiling开销"
    mfu_calculation_mode: "estimate"
    performance_monitoring:
      measure_flops_frequency: 0  # 不测量FLOPs
      use_precise_mfu: false
  
  # 实验4: 混合模式 (推荐用于复杂环境)
  hybrid_mode:
    description: "混合MFU计算 - 硬件计数器 + profiler回退"
    mfu_calculation_mode: "hybrid"
    performance_monitoring:
      measure_flops_frequency: 200
      hybrid_mode:
        hardware_counters_enabled: true
        fallback_to_profiler: true

# 性能基准配置
benchmarks:
  # 基准测试配置
  baseline:
    description: "基准测试 - 不进行MFU计算"
    mfu_calculation_mode: "none"
    performance_monitoring:
      enabled: false
  
  # 性能对比配置
  comparison:
    description: "性能对比测试"
    test_duration_steps: 1000
    warmup_steps: 100
    measurement_interval: 10
    
    # 性能指标
    metrics:
      - "throughput"
      - "memory_usage"
      - "cpu_utilization"
      - "gpu_utilization"
      - "mfu_accuracy"
      - "mfu_overhead"

# 使用说明
usage_notes: |
  # MFU计算方法使用指南
  
  ## 1. 智能模式 (smart) - 推荐用于生产环境
  - 首次使用PyTorch Profiler进行精确测量
  - 计算校准因子，后续使用校准的估算方法
  - 平衡精度和性能，适合长期训练
  
  ## 2. Profiler模式 (profiler) - 推荐用于研究/调试
  - 每次使用PyTorch Profiler进行精确测量
  - 最高精度，但性能开销较大
  - 适合需要精确MFU值的场景
  
  ## 3. 估算模式 (estimate) - 推荐用于快速原型
  - 基于模型结构进行FLOPs估算
  - 无profiling开销，速度最快
  - 精度中等，适合快速迭代
  
  ## 4. 混合模式 (hybrid) - 推荐用于复杂环境
  - 尝试使用硬件计数器
  - 硬件计数器失败时回退到profiler
  - 适合有硬件计数器支持的环境
  
  ## 性能影响总结
  - 估算方法: CPU开销 < 1%, GPU开销 0%, 内存开销 < 10MB
  - 智能方法: CPU开销 首次5-15%后续<1%, GPU开销 首次2-8%后续0%, 内存开销 首次100-500MB后续<10MB
  - Profiler方法: CPU开销 5-15%, GPU开销 2-8%, 内存开销 100-500MB
  - 混合方法: CPU开销 2-10%, GPU开销 1-5%, 内存开销 50-300MB 